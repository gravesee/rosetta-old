{
    "contents" : "### LANGUAGE TRANSLATIONS GO HERE ###\n\n#' Generate translated code from various R tree models\n#'\n#' This function generates translated code of a specified language and returns\n#' it in a character vector.\n#'\n#' The generated code is written to standard output.  See example for how\n#' to write to a file.\n#'\n#' @param obj a tree-based model object (e.g. gbm, randomForest)\n#' @param lang language to translate object into (e.g. 'sas', 'ecl')\n#' @param pfx string to prepend to each tree prediction 'pfx_TREE_0000N'\n#' @param n number of trees to print. Prints \\code{1:n} tree predictions\n#' @return returns a character vector containing all of the translated text\n#' @export translate\ntranslate <- function(obj, lang=\"sas\", pfx, n) {\n\n  stopifnot(any(class(obj) %in% c(\"gbm\", \"randomForest\")))\n  stopifnot(lang %in% c(\"sas\",\"ecl\"))\n\n  mod.data <- mod.data(obj)\n\n  out <- list()\n  for (i in 1:n) {\n    tree <- pretty.tree(obj, i, mod.data)\n    class(tree) <- c(class(tree), tolower(lang))\n    out[[i]] <- export.pretty.tree(tree, pfx, i, mod.data)\n  }\n\n  out <- c(out, finalizer(obj, lang, pfx, n))\n  do.call(c, out)\n}\n\nexport.pretty.tree <- function(x, pfx, i, mod.data) UseMethod(\"export.pretty.tree\")\n\nexport.pretty.tree.sas <- function(x, pfx, i, mod.data) {\n\n  text <- list(\"\\n\")\n  recurse <- function(x, pfx, n, depth) {\n    sp <- paste(rep(\"  \", depth - 1), collapse = \"\") # spacing\n\n    vid <- x[n,'best'] # variable ID\n    vnm <- mod.data$vars[vid] # variable text\n    val <- x[n, 'split'] # split value\n\n    if (x[n,'status'] == -1) { # base case is terminal node\n      text[[length(text)+1]] <<- sprintf(\"%s%s_TREE_%04d = %s;\\n\", sp, pfx, i, x[n,'pred'])\n      return(text)\n    }\n\n    # create logic for split\n    if (x[n, 'vtype'] == 1) { # numeric split\n      ltxt <- sprintf(\"%sif %s <= %s then do;\\n\", sp, vnm, val)\n      rtxt <- sprintf(\"%sif %s >  %s then do;\\n\", sp, vnm, val)\n    } else { # ordered & factors\n      lvl <- mod.data$lvls[[vid]] # variable levels\n      ids <- if (x[n, 'vtype'] == 2) 1:val else which(toBinary(val) == 1)\n\n      memL <- paste(lvl[ids], collapse = \"','\")\n      memR <- paste(lvl[!(lvl %in% memL)], collapse = \"','\")\n\n      ltxt <- sprintf(\"%sif %s in ('%s') then do;\\n\", sp, vnm, memL)\n      rtxt <- sprintf(\"%sif %s in ('%s') then do;\\n\", sp, vnm, memR)\n    }\n\n    # go left\n    text[[length(text)+1]] <<- ltxt\n    recurse(x, pfx, x[n,'left'], depth+1)\n\n    # else, go right\n    text[[length(text)+1]] <<- sprintf(\"%send; else\\n\", sp)\n    text[[length(text)+1]] <<- rtxt\n    recurse(x, pfx, x[n,'right'], depth+1)\n\n    # check for missing and recurse\n    if (mod.data$miss) {\n      text[[length(text)+1]] <<- sprintf(\"%send; else do;\\n\", sp, vnm)\n      recurse(x, pfx, x[n,'miss'], depth+1)\n    }\n\n    text[[length(text)+1]] <<- sprintf(\"%send;\\n\", sp)\n\n    return(text)\n  }\n\n  outdat <- do.call(c, recurse(x, pfx, 1, 1))\n  outdat\n}\n\nexport.pretty.tree.ecl <- function(x, pfx, i, mod.data) {\n\n  text <- list(sprintf(\"\\n%s_TREE_%04d := \", pfx, i))\n  recurse <- function(x, pfx, n, depth) {\n\n    sp <- paste(rep(\"  \", depth - 1), collapse = \"\") # spacing\n\n    vid <- x[n,'best'] # variable ID\n    vnm <- mod.data$vars[vid] # variable text\n    val <- x[n, 'split'] # split value\n\n    if (x[n,'status'] == -1) { # base case is terminal node\n      text[[length(text)+1]] <<- sprintf(\"%s\", x[n,'pred'])\n      return(text)\n    }\n\n    # create logic for split\n    if (x[n, 'vtype'] == 1) { # numeric split\n      ltxt <- sprintf(\"%s(NULL < %s and %s <= %s) => \", sp, vnm, vnm, val)\n      rtxt <- sprintf(\"\\n%s(%s > %s) => \", sp, vnm, val)\n    } else { # ordered & factors\n      lvl <- mod.data$lvls[[vid]] # variable levels\n      ids <- if (x[n, 'vtype'] == 2) 1:val else which(toBinary(val) == 1)\n\n      memL <- paste(lvl[ids], collapse = \"','\")\n      memR <- paste(lvl[!(lvl %in% memL)], collapse = \"','\")\n\n      ltxt <- sprintf(\"%s(%s in ['%s']) => \", sp, vnm, memL)\n      rtxt <- sprintf(\"\\n%s(%s in ['%s']) => \", sp, vnm, memR)\n    }\n\n    # go left\n    text[[length(text)+1]] <<- \"map(\\n\"\n    text[[length(text)+1]] <<- ltxt\n    recurse(x, pfx, x[n,'left'], depth+1)\n    text[[length(text)+1]] <<- \", \"\n\n    # else, go right\n    text[[length(text)+1]] <<- rtxt\n    recurse(x, pfx, x[n,'right'], depth+1)\n\n    # check for missing and recurse\n    if (mod.data$miss) {\n      text[[length(text)+1]] <<- \", \"\n      recurse(x, pfx, x[n,'miss'], depth+1)\n    }\n\n    text[[length(text)+1]] <<- \")\"\n\n    return(text)\n  }\n\n\n  outdat <- do.call(c, recurse(x, pfx, 1, 1))\n  outdat <- c(outdat, \";\\n\")\n  outdat\n}\n",
    "created" : 1436896122632.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1355194622",
    "id" : "2B0D1011",
    "lastKnownWriteTime" : 1436897745,
    "path" : "F:/R Dev/rosetta/R/translate.R",
    "project_path" : "R/translate.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}